# -*- coding: utf-8 -*-
"""Esperienza1_AmplificatoreOperazionale

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tVt0f4dyyWbFydZrt2XBgA03QUHTSTaG

Laboratorio di Elettronica e Tecniche di Acquisizione Dati

#Esperienza 1: Analisi del funzionamento dell' amplificatore operazionale 741 e studio del guadagno in termini della frequenza

*Laura Francesca Iacob \\
Sara Pieri \\
Sara Schippa*

## 2) Caratterizzazione quantitaiva
"""

#import
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import optimize
import scipy.odr as odr
import math as mt

#Definizione della legge di fit lineare
def funzione_fit(p,x):
  A, B = p
  return B*x + A

#Definizione gaussiana
def gauss_func(x, A, mu, sigma):
  return A*np.exp((-(x-mu)**2)/(2*sigma**2))

#Alimentazione
Vcc_pos=10
Vcc_neg=10

"""###OPEN LOOP"""

#Raccolta dati
print('Guadagno atteso: ~', 10**5)

V_out=np.array([10, 10, 10, 6.8, 5.6, 3.92, 2.24, 1.52, 880*10**(-3), 720*10**(-3)])
errV_out=np.array([0.1, 0.1, 0.1, 0.01, 0.01, 0.01, 0.01, 0.01, 10**(-3),10**(-3)])

V_in=np.array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])
errV_in=np.array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1])

f_ol=np.array([113, 801, 8.36*10**3, 18.4*10**3, 23.2*10**3, 28.3*10**3, 58.1*10**3, 84.4*10**3, 144*10**3, 175*10**3])
errf_ol=np.array([1, 1, 10, 10, 10, 10, 10, 10, 1000, 1000])
f_ol_log=np.log10(f_ol)
errf_ol_log=(1/f_ol)*errf_ol

g_reale= V_out/V_in
g_reale_db = 20*np.log10(g_reale)
errg_reale_db=np.sqrt(((20/V_out)*errV_out)**2+((20/V_in)*errV_in )**2)

#Tabella che riassume i dati raccolti e/o calcolati
tab_a=pd.DataFrame(columns=['V_out [V]', 'ε V_out [V]', 'V_in [V]', 'ε V_in [V]'])
tab_a['V_out [V]']=V_out
tab_a['ε V_out [V]']=errV_out
tab_a['V_in [V]']=V_in
tab_a['ε V_in [V]']=errV_in

cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": ".index_name", "props": "font-style: italic; color: darkgrey; font-weight:normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: #a0a0a0; color: white; text-align: center"}
tab_a.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Tensioni misurate: open loop')

#Tabella che riassume i dati raccolti e/o calcolati
dict_b={'Guadagno': g_reale, 'Guadagno [dB]': g_reale_db, 'ε guadagno [dB]': errg_reale_db, 'f [Hz]': f_ol, 'ε f [Hz]': errf_ol, 'f_log': f_ol_log, 'ε f_log': errf_ol_log}
tab_b=pd.DataFrame(dict_b)

cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": ".index_name", "props": "font-style: italic; color: darkgrey; font-weight:normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: #a0a0a0; color: white; text-align: center"}
tab_b.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Dati sperimentali: open loop')

# Grafico dati sperimentali raccolti
fig,(ax1, ax2) = plt.subplots(2, 1, sharex=True, figsize=(10,6), gridspec_kw={'height_ratios': [0.7, 2]})
fig.subplots_adjust(hspace=0.1)
ax1.grid()
ax2.grid()

ax2.errorbar(f_ol_log, g_reale_db, xerr=errf_ol_log, yerr=errg_reale_db, label='Dati', fmt='o', color='black')
ax1.plot(np.array([f_ol_log[0], f_ol_log[9]]), np.array([20*np.log10(10**5), 20*np.log10(10**5)]), label='Guadagno teorico', color='forestgreen')
ax2.plot(np.array([f_ol_log[0], f_ol_log[3]]), np.array([20*np.log10(Vcc_pos), 20*np.log10(Vcc_pos)]), label='Limite di saturazione', color='grey')

ax1.set_ylim(96, 106)
ax2.set_ylim(-10, 30)
ax2.set_xlabel('Frequenza [log_Hz]')

ax1.spines.bottom.set_visible(False)
ax2.spines.top.set_visible(False)
ax1.xaxis.tick_top()
ax1.tick_params(labeltop=False)
ax2.xaxis.tick_bottom()

ax1.legend()
ax2.legend(loc='lower left')
ax1.set_title('Dati sperimentali: open loop')
plt.ylabel('Guadagno [dB]')
plt.show()

#Estrazione dei dati per compiere il fit lineare decrescente (prendo ultimi 4 dati)
f_log_giu=f_ol_log[6:]
errf_log_giu=errf_ol_log[6:]
g_reale_db_giu=g_reale_db[6:]
errg_reale_db_giu=errg_reale_db[6:]

#Indice di Correlazione Lineare
f_log_giu_medio = np.mean(f_log_giu)
g_reale_db_giu_medio = np.mean(g_reale_db_giu)
r=np.sum((f_log_giu-f_log_giu_medio)*(g_reale_db_giu-g_reale_db_giu_medio))/np.sqrt(np.sum((f_log_giu-f_log_giu_medio)**2)*np.sum((g_reale_db_giu-g_reale_db_giu_medio)**2))
print('Indice di correlazione lineare:', r)

#Fit andamento lineare (ODR) dei dati decrescenti
linear_model = odr.Model(funzione_fit)
data = odr.RealData(f_log_giu, g_reale_db_giu, sx=errf_log_giu, sy=errg_reale_db_giu)
linear_odr = odr.ODR(data, linear_model, beta0=[1., 1.])
linear_out = linear_odr.run()
lob=linear_out.beta
lobs=linear_out.sd_beta

print("Intercetta A: ", lob[0], "+-", lobs[0])
print("Coefficiente angolare B: ", lob[1], "+-", lobs[1])

# Estrazione frequenza alla saturazione: intersezione retta-fit
f_sat_log = (g_reale_db[0]-lob[0])/lob[1]
err_f_sat_log=np.sqrt(((1/lob[1])*errg_reale_db[0])**2 + ((1/lob[1])*lobs[0])**2 + (((g_reale_db[0]-lob[0])/lob[1]**2)*lobs[1])**2)

f_sat = pow(10,f_sat_log)
err_f_sat=pow(10, f_sat_log)*np.log(10)*err_f_sat_log #ricontrollareeeeeeeee
print('Frequenza alla saturazione estratta: ', f_sat, ' +- ', err_f_sat, ' Hz')

# Grafico comprendente il fit lineare
fig, ax = plt.subplots(figsize=(10, 6))
plt.errorbar(f_log_giu, g_reale_db_giu, xerr=errf_log_giu , yerr=errg_reale_db_giu, fmt='o', color='black', label='Dati sperimentali')
plt.plot(f_log_giu, funzione_fit(lob, f_log_giu), color='crimson', label='Fit lineare')
plt.ylabel('Guadagno [dB]')
plt.xlabel('Frequenza [log_Hz]')
plt.title('Confronto dati e fit lineare: open loop')
ins_ax=ax.inset_axes([0.6,0.6,0.39,0.39])
ins_ax.errorbar(f_ol_log, g_reale_db, xerr=errf_ol_log, yerr=errg_reale_db, fmt='.', alpha=0.6, color='black')
ins_ax.plot(np.array([f_ol_log[0], f_ol_log[5]]), np.array([g_reale_db[0], g_reale_db[0]]), color='grey')
ins_ax.plot(f_ol_log[2:], funzione_fit(lob, f_ol_log[2:]), color='crimson')
ins_ax.plot(np.full(7, f_sat_log), np.linspace(min(g_reale_db), g_reale_db[0], 7), '|', color='orchid')
ins_ax.grid()
plt.legend(loc='lower left')
plt.grid()
plt.show()

#Test del chi2 per valutare la bontà del fit ODR
dgf=len(V_out)-1
Oh=g_reale_db_giu
Eh=funzione_fit(linear_out.beta, f_log_giu)
chi2=np.sum(pow(Eh-Oh,2)/abs(Eh))
print('Chi2: ', chi2)
chi2_r= chi2/dgf
print ('Chi2 ridotto: ', chi2_r)

#Riassunto risultati ottenuti con il fit
df=pd.DataFrame(columns=['', 'r', "A [dB]", "B [dB/decade]", "x2r"])
df[''] = np.array(['Valore','Veridicità'])
df['r']=np.array([r.round(2), '100%'])
df["A [dB]"]=np.array([linear_out.beta[0],linear_out.sd_beta[0]])
df["B [dB/decade]"]=np.array([linear_out.beta[1],linear_out.sd_beta[1]])
df["x2r"]=np.array([chi2_r.round(2), '100%'])
cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": " index_name", "props": "font-style: italic; color: darkgrey; font-weight: normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: #a0a0a0; color: white; text-align: center"}
df.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Parametri caratterizzanti il fit: open loop')

"""####Estrazione risultati"""

#Riassunto dati pendenza
df=pd.DataFrame(columns=['Indice', 'Valori [dB]', 'Incertezze [dB]'])
df['Indice'] = ['Teorico', 'Sperimentale']
df['Valori [dB]'] = np.array([-20, linear_out.beta[1]])
df['Incertezze [dB]'] = np.array([0, linear_out.sd_beta[1]])
df.round(2)

# Frequenza di saturazione
print('Frequenza alla saturazione estratta: ', f_sat, '+-', err_f_sat, 'Hz')

#Estrazione del GBP dalla retta di fit
GBP=2*np.pi*pow(10, lob[0]/20)
err_GBP=2*np.pi*pow(10, lob[0]/20)*lobs[0]*(1/20) #da ricontrollareeeeee

print('GBP: ', GBP, ' +- ', err_GBP)

#Riassunto risultati ottenuti con il fit
df=pd.DataFrame(columns=['', 'pendenza [dB/decade]', 'f saturazione [Hz]', 'GBP [Hz]'])
df[''] = np.array(['Valore','Errore'])
df['pendenza [dB/decade]']=np.array([linear_out.beta[1], linear_out.sd_beta[1]])
df["f saturazione [Hz]"]=np.array([f_sat, err_f_sat])
df["GBP [Hz]"]=np.array([GBP, err_GBP])

cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": " index_name", "props": "font-style: italic; color: darkgrey; font-weight: normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: #a0a0a0; color: white; text-align: center"}
df.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Parametri quantitativi estratti: open loop')

"""###INVERTENTE"""

#Configurazione circuitale fissa
R_f=5600
errR_f=0.01*R_f
R_1=1200
errR_1=0.05*R_1

g_ideale=-R_f/R_1
err_g_ideale=np.sqrt(((1/R_1)*errR_f)**2 + ((R_f/R_1**2)*errR_1)**2)

#Raccolta dei dati mediante oscilloscopio digitale (anche f con scala dei tempi)
V_out=np.array([4.4, 4.4, 4.4, 4, 3, 2.4, 2, 1.4, 1, 0.6, 0.48, 0.4, 0.32])
errV_out=np.array([0.4, 0.4, 0.4, 0.4, 0.2, 0.2, 0.2, 0.2, 0.1, 40*10**(-3), 40*10**(-3), 40*10**(-3), 40*10**(-3)])

V_in=np.array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])
errV_in=np.array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1])

t=np.array([5*0.01, 1520*10**(-6), 84*10**(-6), 33*10**(-6), 23*10**(-6), 18*10**(-6),  15*10**(-6), 10*10**(-6), 7.6*10**(-6), 4.6*10**(-6), 4*10**(-6), 2.9*10**(-6), 2.2*10**(-6)])
errt=np.array([0.01/5, 40*10**(-6), 4*10**(-6), 10**(-6), 10**(-6), 10**(-6), 10**(-6), 0.4*10**(-6), 0.4*10**(-6), 0.2*10**(-6), 0.2*10**(-6), 1*10**(-9), 1*10**(-9)])

f1=1/t
#f11=np.array([20.0, 660, 11900, 30300, 43500, 55000, 66000, 100000, 132000, 217000, 250000, 345000, 454000])

errf1=f1**2 * errt
#errf11=np.array([0.1, 10, 100, 100, 100, 100, 100, 1000, 1000, 1000, 1000, 1000, 1000])

f1_log=np.log10(f1)
#f11_log=np.log10(f11)

errf1_log=(f1_log**3)*errt
#errf1_log1=(1/f11)*errf11


#Calcolo dei rispettivi guadagni
g_reale1= V_out/V_in
err_g_reale1=np.sqrt(((1/V_in)*errV_out)**2 + ((V_out/V_in**2)*errV_in)**2)
g_reale1_db = 20*np.log10(g_reale1)     #in decibel perchè scala logaritmica
errg_reale1_db=np.sqrt(((20/V_out)*errV_out)**2+((20/V_in)*errV_in )**2)

#Tabella che riassume i dati raccolti e/o calcolati
dict={'V_out [V]': V_out, 'ε V_out [V]': errV_out, 'V_in [V]':V_in, 'ε V_in [V]':errV_in}
tab_a1=pd.DataFrame(dict)

cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": ".index_name", "props": "font-style: italic; color: darkgrey; font-weight:normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: #008080; color: white; text-align: center"}
tab_a1.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Tensioni misurate: invertente I')

#Tabella che riassume i dati raccolti e/o calcolati
dict={'Guadagno': g_reale1, 'Guadagno [dB]': g_reale1_db, 'ε guadagno [dB]': errg_reale1_db, 'f [Hz]': f1, 'ε f [Hz]':errf1, 'f_log': f1_log, 'ε f_log': errf1_log}
tab_a2=pd.DataFrame(dict)

cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": ".index_name", "props": "font-style: italic; color: darkgrey; font-weight:normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: #008080; color: white; text-align: center"}
tab_a2.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Dati sperimentali: invertente I')

#Estrazione dei dati per compiere il fit lineare decrescente (Seleziono solo ultime 7 misure)
f1_log_giu=f1_log[6:]
errf1_log_giu=errf1_log[6:]
g_reale1_db_giu=g_reale1_db[6:]
errg_reale1_db_giu=errg_reale1_db[6:]

#Grafico dell'andamento dei dati
plt.figure(figsize=(10,6))
plt.title('Dati sperimentali: intertente I')
plt.errorbar(f1_log, g_reale1_db, xerr=errf1_log, yerr=errg_reale1_db, label='Dati', fmt='o', color='teal')
plt.plot(np.array([f1_log[0], f1_log[len(f1_log)-1]]), np.full(2, 20*np.log10((-1)*g_ideale)), label='Guadagno teorico', color='gray')
plt.xlabel('Frequenza [log_Hz]')
plt.ylabel('Guadagno [dB]')
plt.legend(loc='lower left')
plt.grid()
plt.show()

#Indice di Correlazione Lineare
f1_log_giu_medio = np.mean(f1_log_giu)
g_reale1_db_giu_medio = np.mean(g_reale1_db_giu)
r=np.sum((f1_log_giu-f1_log_giu_medio)*(g_reale1_db_giu-g_reale1_db_giu_medio))/np.sqrt(np.sum((f1_log_giu-f1_log_giu_medio)**2)*np.sum((g_reale1_db_giu-g_reale1_db_giu_medio)**2))
print('Indice di correlazione lineare:', r)

#Fit andamento lineare (ODR) dei dati decrescenti
linear_model = odr.Model(funzione_fit)
data = odr.RealData(f1_log_giu, g_reale1_db_giu, sx=errf1_log_giu, sy=errg_reale1_db_giu)
linear_odr = odr.ODR(data, linear_model, beta0=[1., 1.])
linear_out = linear_odr.run()
lob1=linear_out.beta
lobs1=linear_out.sd_beta

print("Intercetta A: ", lob1[0], "+-", lobs1[0])
print("Coefficiente angolare B: ", lob1[1], "+-", lobs1[1])

#Frequenza cutoff: intersezione retta-fit
f1_cut_log = (g_reale1_db[0]-lob1[0])/lob1[1]
err_f1_cut_log=np.sqrt(((1/lob1[1])*errg_reale1_db[0])**2 + ((1/lob1[1])*lobs1[0])**2 + (((g_reale1_db[0]-lob1[0])/lob1[1]**2)*lobs1[1])**2)

f1_cut = pow(10,f1_cut_log)
err_f1_cut=pow(10, f1_cut_log)*err_f1_cut_log #ricontrollareeeeeeeee
print('Frequenza di cutoff (intersezione con fit): ', f1_cut, ' +- ', err_f1_cut, ' Hz')

# Grafico comprendente il fit lineare
fig, ax = plt.subplots(figsize=(10, 6))
plt.title('Confronto dati e fit lineare: invertente I')
plt.errorbar(f1_log_giu, g_reale1_db_giu, xerr=errf1_log_giu, yerr=errg_reale1_db_giu, label='Dati sperimentali', fmt='o', color='teal')
plt.plot(f1_log_giu, funzione_fit(lob1, f1_log_giu), label='Fit lineare', color='crimson')
plt.xlabel('Frequenza [log_Hz]')
plt.ylabel('Guadagno [dB]')
ins_ax=ax.inset_axes([0.6,0.6,0.39,0.39])
ins_ax.errorbar(f1_log, g_reale1_db, xerr=errf1_log, yerr=errg_reale1_db, fmt='.', alpha=0.6, color='teal')
ins_ax.plot(np.array([f1_log[0], f1_log[5]]), np.array([g_reale1_db[0], g_reale1_db[0]]), color='gray')
ins_ax.plot(f1_log[2:]+0.1, funzione_fit(lob1, f1_log[2:]+0.1), color='crimson')
ins_ax.plot(np.full(7, f1_cut_log), np.linspace(min(g_reale1_db), g_reale1_db[0], 7), '|', color='orchid')
ins_ax.grid()
plt.legend(loc='lower left')
plt.grid()
plt.show()

#Test del chi2 per valutare la bontà del fit ODR
dgf=len(V_out)-1

Oh=g_reale1_db_giu
Eh=funzione_fit(linear_out.beta, f1_log_giu)
chi2=np.sum(pow(Eh-Oh,2)/abs(Eh))
print('Chi2: ', chi2)
chi2_r= chi2/dgf
print ('Chi2 ridotto: ', chi2_r)

#Riassunto risultati ottenuti con il fit
df=pd.DataFrame(columns=['', 'r', "A [dB]", "B [dB/decade]", "x2r"])
df[''] = np.array(['Valore','Veridicità'])
df['r']=np.array([r.round(2), '100%'])
df["A"]=np.array([lob1[0],lobs1[0]])
df["B"]=np.array([lob1[1],lobs1[1]])
df["x2r"]=np.array([chi2_r.round(2), '100%'])
cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": ".index_name", "props": "font-style: italic; color: darkgrey; font-weight:normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: #008080; color: white; text-align: center"}
df.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Parametri caratterizzanti il fit: invertente I')

"""#### Estrazione risultati"""

#Riassunto dati pendenza
df=pd.DataFrame(columns=['Indice', 'Valori [dB]', 'Incertezze [dB]'])
df['Indice'] = ['Teorico', 'Sperimentale']
df['Valori [dB]'] = np.array([-20, linear_out.beta[1]])
df['Incertezze [dB]'] = np.array([0, linear_out.sd_beta[1]])
df.round(2)

#Frequenza cutoff: intersezione retta-fit
print('Frequenza di cutoff (estrazione con fit): ', f1_cut, ' +- ', err_f1_cut, ' Hz')

#Estrazione del GBP dalla retta di fit
GBP1=2*np.pi*pow(10, lob1[0]/20)
err_GBP1=2*np.pi*pow(10, lob1[0]/20)*lobs1[0]*(1/20) #da ricontrollareeeeee

print('GBP: ', GBP1, ' +- ', err_GBP1)

#Riassunto risultati ottenuti con il fit
df=pd.DataFrame(columns=['', 'pendenza [dB/decade]', 'f cutoff [Hz]', 'GBP [Hz]'])
df[''] = np.array(['Valore','Errore'])
df['pendenza [dB/decade]']=np.array([lob1[1], lobs1[1]])
df["f cutoff [Hz]"]=np.array([f1_cut, err_f1_cut])
df["GBP [Hz]"]=np.array([GBP1, err_GBP1])

cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": " index_name", "props": "font-style: italic; color: darkgrey; font-weight: normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: teal; color: white; text-align: center"}
df.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Parametri quantitativi estratti: invertente I')

"""###INTEGRATORE I"""

C=22*10**(-9)
err_C=0.10*C

R1=1200
err_R1=1200*0.05
R2=3900
err_R2=0.05*R2

V_out=np.array([3.12, 3.12, 3.12, 3.04, 5.85/2, 5.66/2, 5.30/2, 2.24, 2.05, 1.56, 1.02, 0.62, 0.5, 330*10**(-3), 0.220])
errV_out=np.array([0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 10**(-3), 10**(-3), 10**(-3), 10**(-3)])
V_in=np.array([1,1,1,1,1,1,1,1,1,1,1,1,1,1,1])
errV_in=np.array([0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1])
g_reale=V_out/V_in
g_reale_db=20*np.log10(g_reale)
errg_reale_db=np.sqrt(((20/V_out)*errV_out)**2+((20/V_in)*errV_in )**2)

f=np.array([36.8, 58.5, 110, 485, 757, 934, 1200, 1890, 2250, 3330, 5550, 10000, 13000, 20400, 30500])
err_f=np.array([0.1, 0.1, 1, 1, 1, 1, 10, 10, 10, 10, 10, 100, 100, 100, 100])
f_log=np.log10(f)
errf_log=(1/f)*err_f

fc=1/(2*np.pi*R2*C)
err_fc=(1/(2*np.pi))*np.sqrt(pow((err_R2/(C*R2*R2)), 2)+pow((err_C/(R2*C*C)), 2))

#Guadagno con resistenza di controllo
g_ideale=(R2/R1)*(1/np.sqrt(1+(f/fc)**2))
g_ideale_db=20*np.log10(g_ideale)

#Tabella che riassume i dati raccolti e/o calcolati
dict={'V_out [V]': V_out, 'ε V_out [V]': errV_out, 'V_in [V]':V_in, 'ε V_in [V]':errV_in}
tab_a1=pd.DataFrame(dict)

cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": ".index_name", "props": "font-style: italic; color: darkgrey; font-weight:normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: darkviolet; color: white; text-align: center"}
tab_a1.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Tensioni misurate: integratore I')

#Tabella che riassume i dati raccolti e/o calcolati
dict={'Guadagno': g_reale, 'Guadagno [dB]': g_reale_db, 'ε guadagno [dB]': errg_reale_db, 'f [Hz]': f, 'ε f [Hz]':err_f, 'f_log': f_log, 'ε f_log': errf_log}
tab_c=pd.DataFrame(dict)

cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": ".index_name", "props": "font-style: italic; color: darkgrey; font-weight:normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: darkviolet; color: white; text-align: center"}
tab_c.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Dati sperimentali: integratore I')

#Estrazione dei dati per compiere il fit lineare decrescente
f_log_giu=f_log[12:]
errf_log_giu=errf_log[12:]
g_reale_db_giu=g_reale_db[12:]
errg_reale_db_giu=errg_reale_db[12:]

#Grafico dell'andamento dei dati
plt.figure(figsize=(10,6))
plt.title('Dati sperimentali: integratore I')
plt.errorbar(f_log, g_reale_db, xerr=errf_log, yerr=errg_reale_db, label='Dati', fmt='o', color='darkviolet')
plt.plot(f_log, g_ideale_db, label='Guadagno teorico', color='grey')
plt.xlabel('Frequenza [log_Hz]')
plt.ylabel('Guadagno [dB]')
plt.legend()
plt.grid()
plt.show()

#Fit andamento lineare (ODR) dei dati decrescenti
linear_model = odr.Model(funzione_fit)
data = odr.RealData(f_log_giu, g_reale_db_giu, sx=errf_log_giu, sy=errg_reale_db_giu)
linear_odr = odr.ODR(data, linear_model, beta0=[1., 1.])
linear_out = linear_odr.run()
lob_int=linear_out.beta
lobs_int=linear_out.sd_beta

print("Intercetta A: ", lob_int[0], "+-", lobs_int[0])
print("Coefficiente angolare B: ", lob_int[1], "+-", lobs_int[1])

#Frequenza cutoff: intersezione retta-fit
f_cut_log = (g_reale_db[0]-lob_int[0])/lob_int[1]
err_f_cut_log=np.sqrt(((1/lob_int[1])*errg_reale_db[0])**2 + ((1/lob_int[1])*lobs_int[0])**2 + (((g_reale_db[0]-lob_int[0])/lob1[1]**2)*lobs_int[1])**2)

f_cut = pow(10,f_cut_log)
err_f_cut=pow(10, f_cut_log)*err_f_cut_log
print('Frequenza di cutoff (intersezione con fit): ', f_cut, ' +- ', err_f_cut, ' Hz')

# Grafico comprendente il fit lineare
fig, ax = plt.subplots(figsize=(10, 6))
plt.title('Confronto dati e fit lineare: integratore I')
plt.errorbar(f_log_giu, g_reale_db_giu, xerr=errf_log_giu, yerr=errg_reale_db_giu, label='Dati sperimentali', fmt='o', color='darkviolet')
plt.plot(f_log_giu, funzione_fit(lob_int, f_log_giu), label='Fit lineare', color='crimson')
plt.xlabel('Frequenza [log_Hz]')
plt.ylabel('Guadagno [dB]')
ins_ax=ax.inset_axes([0.6,0.6,0.39,0.39])
ins_ax.errorbar(f_log, g_reale_db, xerr=errf_log, yerr=errg_reale_db, fmt='.', alpha=0.6, color='darkviolet')
ins_ax.plot(np.array([f_log[0], f_log[9]]), np.array([g_reale_db[0], g_reale_db[0]]), color='gray')
ins_ax.plot(f_log[6:], funzione_fit(lob_int, f_log[6:]), color='crimson')
ins_ax.plot(np.full(7, f_cut_log), np.linspace(min(g_reale_db), g_reale_db[0], 7), '|', color='orchid')
ins_ax.grid()
plt.legend(loc='lower left')
plt.grid()
plt.show()

"""####Estrazione risultati"""

#Riassunto risultati ottenuti con il fit
df=pd.DataFrame(columns=['', 'pendenza [dB/decade]', 'f cutoff sperimentale [Hz]', 'f cutoff teorica [Hz]'])
df[''] = np.array(['Valore','Errore'])
df['pendenza [dB/decade]']=np.array([lob_int[1], lobs_int[1]])
df["f cutoff sperimentale [Hz]"]=np.array([f_cut, err_f_cut])
df["f cutoff teorica [Hz]"]=np.array([fc, err_fc])

cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": " index_name", "props": "font-style: italic; color: darkgrey; font-weight: normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: darkviolet; color: white; text-align: center"}
df.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Parametri quantitativi estratti: integratore I')

#Confronto valore teorico e sperimentale per fcut

#Compatibilità risultati ottenuti-attesi
scarto=abs(fc-f_cut)
quadratura=np.sqrt(err_fc*err_fc+err_f_cut*err_f_cut)
fattore_t=scarto/quadratura

tabgauss = pd.DataFrame(columns=['Fattore t in σ', 'Veridicità'])
print("Confronto Dati: Metodo Gaussiano")
tabgauss['Fattore t in σ'] = np.array([fattore_t])
tabgauss['Veridicità'] = np.array(['~80%'])
tabgauss.round(2)

#Grafico di compatibilità mediante test gaussiano
plt.subplots(figsize=(7,4))
bincenters=np.arange(-650,800,0.01)
plt.plot(bincenters, gauss_func(bincenters, 1, scarto, quadratura), color='darkviolet')
plt.plot(np.full(11, 0), np.arange(0, 1.07, 1.07/11), color='grey', label='0.24σ')
plt.errorbar(np.full(13, scarto), np.arange(0,1.05, 1.05/13), fmt='|', color='blue', alpha=0.5, label='μ')
plt.errorbar(np.full(11, scarto-quadratura), np.arange(0,0.65, 0.65/11), fmt='|', color='coral')
plt.errorbar(np.full(11, scarto+quadratura), np.arange(0,0.65, 0.65/11), fmt='|', color='coral', label='μ+σ')
plt.xlabel('Valori estratti')
plt.ylabel('Eventi/Bin')
plt.legend()
plt.title("Gaussiana di compatibilità: integratore I")
plt.show()

"""###INTEGRATORE II"""

C0=22*10**(-12)
err_C0=0.10*C0


V_out=np.array([3.14, 3.14, 3.12, 3.12, 3.13, 3.04, 3, 5.80/2, 5.46/2, 3.48/2, 2.36/2, 0.9])
errV_out=np.array([0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01])
V_in=np.array([1,1,1,1,1,1,1,1,1,1,1,1])
errV_in=np.array([0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1])
g_reale0=V_out/V_in
g_reale0_db=20*np.log10(g_reale0)
errg_reale0_db=np.sqrt(((20/V_out)*errV_out)**2+((20/V_in)*errV_in )**2)

f0=np.array([104, 121, 161, 207, 295, 1000, 27000, 35500, 43000, 72500, 106000, 143000])
err_f0=np.array([1, 1, 1, 1, 1, 10, 100, 100, 100, 100, 1000, 1000])
f0_log=np.log10(f0)
errf0_log=(1/f0)*err_f0

f0c=1/(2*np.pi*R2*C0)
err_f0c=(1/(2*np.pi))*np.sqrt(pow((err_R2/(C0*R2*R2)), 2)+pow((err_C0/(R2*C0*C0)), 2))

#Guadagno con resistenza di controllo
g_ideale0=(R2/R1)*(1/np.sqrt(1+(f0/f0c)**2))
g_ideale0_db=20*np.log10(g_ideale0)

#Tabella che riassume i dati raccolti e/o calcolati
dict={'V_out [V]': V_out, 'ε V_out [V]': errV_out, 'V_in [V]':V_in, 'ε V_in [V]':errV_in}
tab_a1=pd.DataFrame(dict)

cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": ".index_name", "props": "font-style: italic; color: darkgrey; font-weight:normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: mediumspringgreen; color: white; text-align: center"}
tab_a1.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Tensioni misurate: integratore II')

#Tabella che riassume i dati raccolti e/o calcolati
dict={'Guadagno': g_reale0, 'Guadagno [dB]': g_reale0_db, 'ε guadagno [dB]': errg_reale0_db, 'f [Hz]': f0, 'ε f [Hz]':err_f0, 'f_log': f0_log, 'ε f_log': errf0_log}
tab_c=pd.DataFrame(dict)

cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": ".index_name", "props": "font-style: italic; color: darkgrey; font-weight:normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: mediumspringgreen; color: white; text-align: center"}
tab_c.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Dati sperimentali: integratore II')

#Estrazione dei dati per compiere il fit lineare decrescente
f0_log_giu=f0_log[9:]
errf0_log_giu=errf0_log[9:]
g_reale0_db_giu=g_reale0_db[9:]
errg_reale0_db_giu=errg_reale0_db[9:]

#Grafico dell'andamento dei dati
plt.figure(figsize=(10,6))
plt.title('Dati sperimentali: integratore II')
plt.errorbar(f0_log, g_reale0_db, xerr=errf0_log, yerr=errg_reale0_db, label='Dati', fmt='o', color='mediumspringgreen')
qualcosa=np.arange(f0[0],30000000, 100000)
patatina=20*np.log10((R2/R1)*(1/np.sqrt(1+(qualcosa/f0c)**2)))
plt.plot(np.log10(qualcosa), patatina, label='Guadagno teorico', color='forestgreen')
plt.xlabel('Frequenza [log_Hz]')
plt.ylabel('Guadagno [dB]')
plt.ylim(-5, 15)
plt.legend()
plt.grid()
plt.show()

#Fit andamento lineare (ODR) dei dati decrescenti
linear_model = odr.Model(funzione_fit)
data = odr.RealData(f0_log_giu, g_reale0_db_giu, sx=errf0_log_giu, sy=errg_reale0_db_giu)
linear_odr = odr.ODR(data, linear_model, beta0=[1., 1.])
linear_out = linear_odr.run()
lob_int0=linear_out.beta
lobs_int0=linear_out.sd_beta

print("Intercetta A: ", lob_int0[0], "+-", lobs_int0[0])
print("Coefficiente angolare B: ", lob_int0[1], "+-", lobs_int0[1])

#Frequenza cutoff: intersezione retta-fit
f0_cut_log = (g_reale0_db[0]-lob_int0[0])/lob_int0[1]
err_f0_cut_log=np.sqrt(((1/lob_int0[1])*errg_reale0_db[0])**2 + ((1/lob_int0[1])*lobs_int0[0])**2 + (((g_reale0_db[0]-lob_int0[0])/lob1[1]**2)*lobs_int0[1])**2)

f0_cut = pow(10,f0_cut_log)
err_f0_cut=pow(10, f0_cut_log)*err_f0_cut_log
print('Frequenza di cutoff (intersezione con fit): ', f0_cut, ' +- ', err_f0_cut, ' Hz')

# Grafico comprendente il fit lineare
fig, ax = plt.subplots(figsize=(10, 6))
plt.title('Confronto dati e fit lineare: integratore II')
plt.errorbar(f0_log_giu, g_reale0_db_giu, xerr=errf0_log_giu, yerr=errg_reale0_db_giu, label='Dati sperimentali', fmt='o', color='mediumspringgreen')
plt.plot(f0_log_giu, funzione_fit(lob_int0, f0_log_giu), label='Fit lineare', color='crimson')
plt.xlabel('Frequenza [log_Hz]')
plt.ylabel('Guadagno [dB]')
ins_ax=ax.inset_axes([0.6,0.6,0.39,0.39])
ins_ax.errorbar(f0_log, g_reale0_db, xerr=errf0_log, yerr=errg_reale0_db, fmt='.', alpha=0.6, color='mediumspringgreen')
ins_ax.plot(np.array([f0_log[0], f0_log[9]]), np.array([g_reale0_db[0], g_reale0_db[0]]), color='gray')
ins_ax.plot(f0_log[6:], funzione_fit(lob_int0, f0_log[6:]), color='crimson')
ins_ax.plot(np.full(7, f0_cut_log), np.linspace(min(g_reale0_db), g_reale0_db[0], 7), '|', color='orchid')
ins_ax.grid()
plt.legend(loc='lower left')
plt.grid()
plt.show()

"""####Verifica di schiacciamento"""

#Riassunto risultati ottenuti con il fit
df=pd.DataFrame(columns=['', 'pendenza [dB/decade]', 'f cutoff sperimentale [Hz]', 'f cutoff teorica [Hz]'])
df[''] = np.array(['Valore','Errore'])
df['pendenza [dB/decade]']=np.array([lob_int0[1], lobs_int0[1]])
df["f cutoff sperimentale [Hz]"]=np.array([f0_cut, err_f0_cut])
df["f cutoff teorica [Hz]"]=np.array([f0c, err_f0c])

cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": " index_name", "props": "font-style: italic; color: darkgrey; font-weight: normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: mediumspringgreen; color: white; text-align: center"}
df.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Parametri quantitativi estratti: integratore II')

#Confronto valore teorico e sperimentale per fcut

#Compatibilità risultati ottenuti-attesi
scarto=abs(f0c-f0_cut)
quadratura=np.sqrt(err_f0c*err_f0c+err_f0_cut*err_f0_cut)
fattore_t=scarto/quadratura

tabgauss = pd.DataFrame(columns=['Fattore t in σ', 'Veridicità'])
print("Confronto Dati: Metodo Gaussiano")
tabgauss['Fattore t in σ'] = np.array([fattore_t])
tabgauss['Veridicità'] = np.array(['0%'])
tabgauss.round(2)

"""##3) Analisi delle frequenze a guadagni differenti

###INVERTENTE III
"""

#3° configurazione
R_f3=9500 #due in serie
errR_f=np.sqrt(0.05**2 + 0.05**2)
R_13=1200
errR_13=0.05*R_13
g_ideale3=-R_f3/R_13

V_out3=np.array([7.7, 7.7, 7.7, 7.7, 7.5, 6.5, 11.4/2, 9.4/2, 5.20/2, 2, 1.70, 1.3, 1.7/2])
errV_out3=np.array([0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01])

V_in=np.array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])
errV_in=np.array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1])

f3=np.array([809, 1510, 2020, 4200, 14100, 18500, 22300, 26600, 49000, 69400, 82300, 110000, 154000])
err_f3=np.array([1, 10, 10, 10, 100, 100, 100, 100, 100, 100, 100, 1000, 1000])
f3_log=np.log10(f3)         #logaritmo perchè serve scala logaritmica per il fit lineare
errf3_log=(1/f3)*err_f3

#Calcolo dei rispettivi guadagni
g_reale3= V_out3/V_in
err_g_reale3=np.sqrt(((1/V_in)*errV_out3)**2 + ((V_out3/V_in**2)*errV_in)**2)

g_reale_db3 = 20*np.log10(g_reale3)     #in decibel perchè scala logaritmica
errg_reale_db3=np.sqrt(((20/V_out3)*errV_out3)**2+((20/V_in)*errV_in )**2)

tab_a=pd.DataFrame(columns=['V_out [V]', 'ε V_out [V]', 'V_in [V]', 'ε V_in [V]'])
tab_a['V_out [V]']=V_out3
tab_a['ε V_out [V]']=errV_out3
tab_a['V_in [V]']=V_in
tab_a['ε V_in [V]']=errV_in

cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": ".index_name", "props": "font-style: italic; color: darkgrey; font-weight:normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: #069AF3; color: white; text-align: center"}
tab_a.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Tensioni misurate: invertente III')

#Tabella che riassume i dati raccolti e/o calcolati
dict_b={'Guadagno': g_reale3, 'Guadagno [dB]': g_reale_db3, 'ε guadagno [dB]': errg_reale_db3, 'f [Hz]': f3, 'ε f [Hz]': err_f3, 'f_log': f3_log, 'ε f_log': errf3_log}
tab_b=pd.DataFrame(dict_b)

cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": ".index_name", "props": "font-style: italic; color: darkgrey; font-weight:normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: #069AF3; color: white; text-align: center"}
tab_b.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Dati sperimentali: invertente III')

f_log_giu3=f3_log[8:]
errf_log_giu3=errf3_log[8:]
g_reale_db_giu3=g_reale_db3[8:]
errg_reale_db_giu3=errg_reale_db3[8:]

plt.figure(figsize=(10,6))
plt.title('Dati sperimentali: invertente III')
plt.errorbar(f3_log, g_reale_db3, xerr=errf3_log, yerr=errg_reale_db3, label='Dati', fmt='o', color='#069AF3')
plt.plot(np.array([f3_log[0], f3_log[12]]), np.full(2, 20*np.log10((-1)*g_ideale3)), label='Guadagno teorico', color='gray')
plt.xlabel('Frequenza [log_Hz]')
plt.ylabel('Guadagno [dB]')
plt.legend()
plt.grid()
plt.show()

f3_log_m = np.mean(f3_log)
g_reale_db3_m= np.mean(g_reale_db3)
r=np.sum((f3_log - f3_log_m)*(g_reale_db3 - g_reale_db3_m))/np.sqrt(np.sum((f3_log - f3_log_m)**2)*np.sum((g_reale_db3 - g_reale_db3_m)**2))
print('Indice di correlazione lineare:', r)

linear_model = odr.Model(funzione_fit)
data = odr.RealData(f_log_giu3, g_reale_db_giu3, sx=errf_log_giu3, sy=errg_reale_db_giu3)
linear_odr = odr.ODR(data, linear_model, beta0=[1., 1.])
linear_out = linear_odr.run()
lob3=linear_out.beta
lobs3=linear_out.sd_beta

print("Intercetta A: ", lob3[0], "+-", lobs3[0])
print("Coefficiente angolare B: ", lob3[1], "+-", lobs3[1])

#Frequenza cutoff
f_cut_log3 = (g_reale_db3[0]-lob3[0])/lob3[1]
err_f_cut_log3=np.sqrt(((1/lob3[1])*errg_reale_db3[0])**2 + ((1/lob3[1])*lobs3[0])**2 + (((g_reale_db3[0]-lob3[0])/lob3[1]**2)*lobs3[1])**2)

print(f_cut_log3)
f_cut3 = pow(10, f_cut_log3)
err_f_cut3=pow(10, f_cut_log3)*err_f_cut_log3
print(f_cut3, ' +- ', err_f_cut3)

# Grafico comprendente il fit lineare
fig, ax = plt.subplots(figsize=(10, 6))
plt.title('Confronto dati e fit lineare: invertente III')
plt.errorbar(f_log_giu3, g_reale_db_giu3, xerr=errf_log_giu3, yerr=errg_reale_db_giu3, label='Dati sperimentali', fmt='o', color='#069AF3')
plt.plot(f_log_giu3, funzione_fit(lob3, f_log_giu3), label='Fit lineare', color='crimson')
plt.xlabel('Frequenza [log_Hz]')
plt.ylabel('Guadagno [dB]')
ins_ax=ax.inset_axes([0.6,0.6,0.39,0.39])
ins_ax.errorbar(f3_log, g_reale_db3, xerr=errf3_log, yerr=errg_reale_db3, fmt='.', alpha=0.6, color='#069AF3')
ins_ax.plot(np.array([f3_log[0], f3_log[7]]), np.array([g_reale_db3[0], g_reale_db3[0]]), color='gray')
ins_ax.plot(f3_log[4:], funzione_fit(lob3, f3_log[4:]), color='crimson')
ins_ax.plot(np.full(7, f_cut_log3), np.linspace(min(g_reale_db3), g_reale_db3[0], 7), '|', color='orchid')
ins_ax.grid()
plt.legend(loc='lower left')
plt.grid()
plt.show()

#Test del chi2 per valutare la bontà del fit ODR
dgf=len(V_out)-1

Oh=g_reale_db_giu3
Eh=funzione_fit(lob3, f_log_giu3)
chi2=np.sum(pow(Eh-Oh,2)/abs(Eh))
print('Chi2: ', chi2)
chi2_r= chi2/dgf
print ('Chi2 ridotto: ', chi2_r)

#Riassunto risultati ottenuti con il fit
df=pd.DataFrame(columns=['', 'r', "A [dB]", "B [dB/decade]", "x2r"])
df[''] = np.array(['Valore','Veridicità'])
df['r']=np.array([r.round(2), '90%'])
df["A [dB]"]=np.array([lob3[0],lobs3[0]])
df["B [dB/decade]"]=np.array([lob3[1],lobs3[1]])
df["x2r"]=np.array([chi2_r.round(2), '100%'])
cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": ".index_name", "props": "font-style: italic; color: darkgrey; font-weight:normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: #069AF3; color: white; text-align: center"}
df.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Parametri caratterizzanti il fit: invertente III')

#Estrazione del GBP dalla retta di fit
GBP3=2*np.pi*pow(10, lob3[0]/20)
gbp3=2*np.pi*f_cut3*(g_reale3[0]-1/np.sqrt(2))
print(gbp3)
err_GBP3=2*np.pi*pow(10, lob3[0]/20)*lobs3[0]*(1/20) #da ricontrollareeeeee

print('GBP: ', GBP3, " +- ", err_GBP3)

#Riassunto risultati ottenuti con il fit
df=pd.DataFrame(columns=['', 'pendenza [dB/decade]', 'f cutoff [Hz]', 'GBP [Hz]'])
df[''] = np.array(['Valore','Errore'])
df['pendenza [dB/decade]']=np.array([lob3[1], lobs3[1]])
df["f cutoff [Hz]"]=np.array([f_cut3, err_f_cut3])
df["GBP [Hz]"]=np.array([GBP3, err_GBP3])

cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": " index_name", "props": "font-style: italic; color: darkgrey; font-weight: normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: #069AF3; color: white; text-align: center"}
df.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Parametri quantitativi estratti: invertente III')

"""###INVERTENTE IV"""

#4° configurazione
R_f4=6200
errR_f4=(5/100)*R_f4
R_14=1200
errR_14=0.05*R_14
g_ideale4=1+(R_f4/R_14)


V_out4=np.array([4.8, 4.8, 4.8, 4.8, 4.8, 3.95, 3.08, 2.04, 1.46, 1.10, 0.97, 0.84, 0.61])
errV_out4=np.full(len(V_out4), 0.01)

V_in=np.full(len(V_out4), 1)
errV_in=np.full(len(V_out4), 0.1)

f4=np.array([133, 555, 1960, 5750, 12600, 30900, 40700, 62500, 87000, 115000, 133000, 154000, 209000])
err_f4=np.array([1,1,10,10,100,100,100,100,100,1000,1000,1000,1000])
f4_log=np.log10(f4)         #logaritmo perchè serve scala logaritmica per il fit lineare
errf4_log=(1/f4)*err_f4

#Calcolo dei rispettivi guadagni
g_reale4= V_out4/V_in
err_g_reale4=np.sqrt(((1/V_in)*errV_out4)**2 + ((V_out4/V_in**2)*errV_in)**2)

g_reale_db4 = 20*np.log10(g_reale4)     #in decibel perchè scala logaritmica
errg_reale_db4=np.sqrt(((20/V_out4)*errV_out4)**2+((20/V_in)*errV_in )**2)

#DataFrame
tab_a=pd.DataFrame(columns=['V_out [V]', 'ε V_out [V]', 'V_in [V]', 'ε V_in [V]'])
tab_a['V_out [V]']=V_out4
tab_a['ε V_out [V]']=errV_out4
tab_a['V_in [V]']=V_in
tab_a['ε V_in [V]']=errV_in

cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": ".index_name", "props": "font-style: italic; color: darkgrey; font-weight:normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: red; color: white; text-align: center"}
tab_a.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Tensioni misurate: invertente IV')

#Tabella che riassume i dati raccolti e/o calcolati
dict_b={'Guadagno': g_reale4, 'Guadagno [dB]': g_reale_db4, 'ε guadagno [dB]': errg_reale_db4, 'f [Hz]': f4, 'ε f [Hz]': err_f4, 'f_log': f4_log, 'ε f_log': errf4_log}
tab_b=pd.DataFrame(dict_b)

cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": ".index_name", "props": "font-style: italic; color: darkgrey; font-weight:normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: red; color: white; text-align: center"}
tab_b.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Dati sperimentali: invertente IV')

#Grafici
f_log_giu4=f4_log[8:]
errf_log_giu4=errf4_log[8:]
g_reale_db_giu4=g_reale_db4[8:]
errg_reale_db_giu4=errg_reale_db4[8:]

plt.figure(figsize=(10,6))
plt.title('Dati sperimentali: invertente IV')
plt.errorbar(f4_log, g_reale_db4, xerr=errf4_log, yerr=errg_reale_db4, label='Dati', fmt='o', color='red')
plt.plot(np.array([f4_log[0], f4_log[11]]), np.full(2, 20*np.log10(g_ideale4)), label='Guadagno teorico', color='gray')
plt.xlabel('Frequenza [log_Hz]')
plt.ylabel('Guadagno [dB]')
plt.legend()
plt.grid()
plt.show()

#FIT
linear_model = odr.Model(funzione_fit)
data = odr.RealData(f_log_giu4, g_reale_db_giu4, sx=errf_log_giu4, sy=errg_reale_db_giu4)
linear_odr = odr.ODR(data, linear_model, beta0=[1., 1.])
linear_out = linear_odr.run()
lob4=linear_out.beta
lobs4=linear_out.sd_beta

print("Intercetta A: ", lob4[0], "+-", lobs4[0])
print("Coefficiente angolare B: ", lob4[1], "+-", lobs4[1])

#Frequenza cutoff
f_cut_log4 = (g_reale_db4[0]-lob4[0])/lob4[1]
err_f_cut_log4=np.sqrt(((1/lob4[1])*errg_reale_db4[0])**2 + ((1/lob4[1])*lobs4[0])**2 + (((g_reale_db4[0]-lob4[0])/lob4[1]**2)*lobs4[1])**2)

f_cut4 = pow(10, f_cut_log4)
err_f_cut4=pow(10, f_cut_log4)*np.log(10)*err_f_cut_log4
print(f_cut4, ' +- ', err_f_cut4)

# Grafico comprendente il fit lineare
fig, ax = plt.subplots(figsize=(10, 6))
plt.title('Confronto dati e fit lineare: invertente IV')
plt.errorbar(f_log_giu4, g_reale_db_giu4, xerr=errf_log_giu4, yerr=errg_reale_db_giu4, label='Dati sperimentali', fmt='o', color='red')
plt.plot(f_log_giu4, funzione_fit(lob4, f_log_giu4), label='Fit lineare', color='maroon')
plt.xlabel('Frequenza [log_Hz]')
plt.ylabel('Guadagno [dB]')
ins_ax=ax.inset_axes([0.6,0.6,0.39,0.39])
ins_ax.errorbar(f4_log, g_reale_db4, xerr=errf4_log, yerr=errg_reale_db4, fmt='.', alpha=0.6, color='red')
ins_ax.plot(np.array([f4_log[0], f4_log[8]]), np.array([g_reale_db4[0], g_reale_db4[0]]), color='gray')
ins_ax.plot(f4_log[4:], funzione_fit(lob4, f4_log[4:]), color='maroon')
ins_ax.plot(np.full(7, f_cut_log4), np.linspace(min(g_reale_db4), g_reale_db4[0], 7), '|', color='orchid')
ins_ax.grid()
plt.legend(loc='lower left')
plt.grid()
plt.show()

#Test del chi2 per valutare la bontà del fit ODR
dgf=len(V_out)-1

Oh=g_reale_db_giu4
Eh=funzione_fit(lob4, f_log_giu4)
chi2=np.sum(pow(Eh-Oh,2)/abs(Eh))
print('Chi2: ', chi2)
chi2_r= chi2/dgf
print ('Chi2 ridotto: ', chi2_r)

#Correlazione lineare
f4_log_m = np.mean(f4_log)
g_reale_db4_m= np.mean(g_reale_db4)
r=np.sum((f4_log - f4_log_m)*(g_reale_db4 - g_reale_db4_m))/np.sqrt(np.sum((f4_log - f4_log_m)**2)*np.sum((g_reale_db4 - g_reale_db4_m)**2))
print('Indice di correlazione lineare:', r)

#Riassunto risultati ottenuti con il fit
df=pd.DataFrame(columns=['', 'r', "A [dB]", "B [dB/decade]", "x2r"])
df[''] = np.array(['Valore','Veridicità'])
df['r']=np.array([r.round(2), '90%'])
df["A [dB]"]=np.array([lob4[0],lobs4[0]])
df["B [dB/decade]"]=np.array([lob4[1],lobs4[1]])
df["x2r"]=np.array([chi2_r.round(2), '100%'])
cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": ".index_name", "props": "font-style: italic; color: darkgrey; font-weight:normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: red; color: white; text-align: center"}
df.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Parametri caratterizzanti fit: invertente IV')

#Estrazione del GBP dalla retta di fit
GBP4=2*np.pi*pow(10, lob2[0]/20)
err_GBP4=2*np.pi*pow(10, lob2[0]/20)*np.log(10)*lobs2[0]*(1/20)

print('GBP: ', GBP4, ' +- ', err_GBP4)

#Riassunto risultati ottenuti con il fit
df=pd.DataFrame(columns=['', 'pendenza [dB/decade]', 'f cutoff [Hz]', 'GBP [Hz]'])
df[''] = np.array(['Valore','Errore'])
df['pendenza [dB/decade]']=np.array([lob4[1], lobs4[1]])
df["f cutoff [Hz]"]=np.array([f_cut4, err_f_cut4])
df["GBP [Hz]"]=np.array([GBP4, err_GBP4])

cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": " index_name", "props": "font-style: italic; color: darkgrey; font-weight: normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: red; color: white; text-align: center"}
df.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Parametri quantitativi estratti: invertente IV')

"""### INVERTENTE V"""

#5° condifurazione
R_f5=3900
errR_f5=0.05*R_f5
R_15=1200
errR_15=0.05*R_15
g_ideale5=-R_f5/R_15

V_out5=np.array([3.10, 3.10, 3.10, 3.06, 2.5, 1.9, 1.42, 1.02, 1.16/2, 410*10**(-3)])
errV_out5=np.array([0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 10**(-3)])

V_in=np.array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])
errV_in=np.array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1])

f5=np.array([992, 2210, 3420, 27000, 48000, 64900, 89300, 123000, 214000, 319000])
err_f5=np.array([1, 10, 10, 100, 100, 100, 100, 1000, 1000, 1000])
f5_log=np.log10(f5)         #logaritmo perchè serve scala logaritmica per il fit lineare
errf5_log=(1/f5)*err_f5

#Calcolo dei rispettivi guadagni
g_reale5= V_out5/V_in
err_g_reale5=np.sqrt(((1/V_in)*errV_out5)**2 + ((V_out5/V_in**2)*errV_in)**2)

g_reale_db5 = 20*np.log10(g_reale5)     #in decibel perchè scala logaritmica
errg_reale_db5=np.sqrt(((20/V_out5)*errV_out5)**2+((20/V_in)*errV_in )**2)

tab_a=pd.DataFrame(columns=['V_out [V]', 'ε V_out [V]', 'V_in [V]', 'ε V_in [V]'])
tab_a['V_out [V]']=V_out5
tab_a['ε V_out [V]']=errV_out5
tab_a['V_in [V]']=V_in
tab_a['ε V_in [V]']=errV_in

cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": ".index_name", "props": "font-style: italic; color: #FFFE0; font-weight:normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: orchid; color: white; text-align: center"}
tab_a.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Tensioni misurate: invertente V')

#Tabella che riassume i dati raccolti e/o calcolati
dict_b={'Guadagno': g_reale5, 'Guadagno [dB]': g_reale_db5, 'ε guadagno [dB]': errg_reale_db5, 'f [Hz]': f5, 'ε f [Hz]': err_f5, 'f_log': f5_log, 'ε f_log': errf5_log}
tab_b=pd.DataFrame(dict_b)

cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": ".index_name", "props": "font-style: italic; color: #FFFE0; font-weight:normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: orchid; color: white; text-align: center"}
tab_b.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Dati sperimentali: invertente V')

f_log_giu5=f5_log[6:]
errf_log_giu5=errf5_log[6:]
g_reale_db_giu5=g_reale_db5[6:]
errg_reale_db_giu5=errg_reale_db5[6:]

plt.figure(figsize=(10,6))
plt.title('Dati sperimentali: invertente V')
plt.errorbar(f5_log, g_reale_db5, xerr=errf5_log, yerr=errg_reale_db5, label='Dati', fmt='o', color='orchid')
plt.plot(np.array([f5_log[0], f5_log[9]]), np.full(2, 20*np.log10((-1)*g_ideale5)), label='Guadagno teorico', color='gray')
plt.xlabel('Frequenza [log_Hz]')
plt.ylabel('Guadagno [dB]')
plt.legend()
plt.grid()
plt.show()

f5_log_m = np.mean(f5_log)
g_reale_db5_m= np.mean(g_reale_db5)
r=np.sum((f5_log - f5_log_m)*(g_reale_db5 - g_reale_db5_m))/np.sqrt(np.sum((f5_log - f5_log_m)**2)*np.sum((g_reale_db5 - g_reale_db5_m)**2))
print('Indice di correlazione lineare:', r)

linear_model = odr.Model(funzione_fit)
data = odr.RealData(f_log_giu5, g_reale_db_giu5, sx=errf_log_giu5, sy=errg_reale_db_giu5)
linear_odr = odr.ODR(data, linear_model, beta0=[1., 1.])
linear_out = linear_odr.run()
lob5=linear_out.beta
lobs5=linear_out.sd_beta

print("Intercetta A: ", lob5[0], "+-", lobs5[0])
print("Coefficiente angolare B: ", lob5[1], "+-", lobs5[1])

#Frequenza cutoff
f_cut_log5 = (g_reale_db5[0]-lob5[0])/lob5[1]
err_f_cut_log5=np.sqrt(((1/lob5[1])*errg_reale_db5[0])**2 + ((1/lob5[1])*lobs5[0])**2 + (((g_reale_db5[0]-lob5[0])/lob5[1]**2)*lobs5[1])**2)

f_cut5 = pow(10, f_cut_log5)
err_f_cut5=pow(10, f_cut_log5)*err_f_cut_log5
print(f_cut5, ' +- ', err_f_cut5)

# Grafico comprendente il fit lineare
fig, ax = plt.subplots(figsize=(10, 6))
plt.title('Confronto dati e fit lineare: invertente V')
plt.errorbar(f_log_giu5, g_reale_db_giu5, xerr=errf_log_giu5, yerr=errg_reale_db_giu5, label='Dati sperimentali', fmt='o', color='orchid')
plt.plot(f_log_giu5, funzione_fit(lob5, f_log_giu5), label='Fit lineare', color='crimson')
plt.xlabel('Frequenza [log_Hz]')
plt.ylabel('Guadagno [dB]')
ins_ax=ax.inset_axes([0.6,0.6,0.39,0.39])
ins_ax.errorbar(f5_log, g_reale_db5, xerr=errf5_log, yerr=errg_reale_db5, fmt='.', alpha=0.6, color='orchid')
ins_ax.plot(np.array([f5_log[0], f5_log[6]]), np.array([g_reale_db5[0], g_reale_db5[0]]), color='gray')
ins_ax.plot(f5_log[3:], funzione_fit(lob5, f5_log[3:]), color='crimson')
ins_ax.plot(np.full(7, f_cut_log5), np.linspace(min(g_reale_db5), g_reale_db5[0], 7), '|', color='orchid')
ins_ax.grid()
plt.legend(loc='lower left')
plt.grid()
plt.show()

#Test del chi2 per valutare la bontà del fit ODR
dgf=len(V_out)-1

Oh=g_reale_db_giu5
Eh=funzione_fit(lob5, f_log_giu5)
chi2=np.sum(pow(Eh-Oh,2)/abs(Eh))
print('Chi2: ', chi2)
chi2_r= chi2/dgf
print ('Chi2 ridotto: ', chi2_r)

#Riassunto risultati ottenuti con il fit
df=pd.DataFrame(columns=['', 'r', "A [dB]", "B [dB/decade]", "x2r"])
df[''] = np.array(['Valore','Veridicità'])
df['r']=np.array([r.round(2), '90%'])
df["A [dB]"]=np.array([lob5[0],lobs5[0]])
df["B [dB/decade]"]=np.array([lob5[1],lobs5[1]])
df["x2r"]=np.array([chi2_r.round(2), '100%'])
cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": ".index_name", "props": "font-style: italic; color: darkgrey; font-weight:normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: orchid; color: white; text-align: center"}
df.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Parametri caratterizzanti il fit: invertente V')

#Estrazione del GBP dalla retta di fit
GBP5=2*np.pi*pow(10, lob5[0]/20)
err_GBP5=(2*np.pi*pow(10, lob5[0]/20)*lobs5[0])*(1/20) #da ricontrollareeeeee

print('GBP: ', GBP5, " +- ", err_GBP5)

#Riassunto risultati ottenuti con il fit
df=pd.DataFrame(columns=['', 'pendenza [dB/decade]', 'f cutoff [Hz]', 'GBP [Hz]'])
df[''] = np.array(['Valore','Errore'])
df['pendenza [dB/decade]']=np.array([lob5[1], lobs5[1]])
df["f cutoff [Hz]"]=np.array([f_cut5, err_f_cut5])
df["GBP [Hz]"]=np.array([GBP5, err_GBP5])

cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": " index_name", "props": "font-style: italic; color: darkgrey; font-weight: normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: orchid; color: white; text-align: center"}
df.style.format(precision=2).set_table_styles([cell_hover, index_names, headers]).set_caption('Parametri quantitativi estratti: invertente V')

"""###Confronto tra configurazioni invertenti"""

#Plot completo delle curve caratteristiche
plt.figure(figsize=(10,6))
plt.title('Confronto misure sperimentali a guadagno differente: invertente')
plt.errorbar(f1_log, g_reale1_db, xerr=errf1_log, yerr=errg_reale1_db, label='Dati I', color='teal', fmt='.')
plt.errorbar(f3_log, g_reale_db3, xerr=errf3_log, yerr=errg_reale_db3, label='Dati III', color='#069AF3', fmt='.')
plt.errorbar(f4_log, g_reale_db4, xerr=errf4_log, yerr=errg_reale_db4, label='Dati IV', color='red', fmt='.')
plt.errorbar(f5_log, g_reale_db5, xerr=errf5_log, yerr=errg_reale_db5, label='Dati V', color='orchid', fmt='.')
plt.xlabel('Frequenza [log_Hz]')
plt.ylabel('Guadagno [dB]')
plt.legend()
plt.errorbar(f1_log, g_reale1_db, xerr=errf1_log, yerr=errg_reale1_db, label='Dati I', color='teal', alpha=0.7)
plt.errorbar(f3_log, g_reale_db3, xerr=errf3_log, yerr=errg_reale_db3, label='Dati III', color='#069AF3', alpha=0.7)
plt.errorbar(f4_log, g_reale_db4, xerr=errf4_log, yerr=errg_reale_db4, label='Dati IV', color='red', alpha=0.7)
plt.errorbar(f5_log, g_reale_db5, xerr=errf5_log, yerr=errg_reale_db5, label='Dati V', color='orchid', alpha=0.7)
plt.grid()
plt.show()

#Plot completo delle curve caratteristiche
plt.figure(figsize=(10,6))
plt.title('Confronto andamenti sperimentali a guadagno differente: invertente')
plt.errorbar(f1_log, g_reale1_db, label='Dati I', color='teal')
plt.errorbar(f3_log, g_reale_db3, label='III', color='#069AF3')
plt.errorbar(f4_log, g_reale_db4, label='IV', color='red')
plt.errorbar(f5_log, g_reale_db5, label='V', color='orchid')
plt.xlabel('Frequenza [log_Hz]')
plt.ylabel('Guadagno [dB]')
plt.xlim(3,5.5)
plt.legend()
plt.grid()
plt.show()

#Plot completo delle rette di fit
plt.figure(figsize=(10,6))
plt.title('Confronto dei fit lineari a guadagno differente: invertente')
plt.plot(f3_log, funzione_fit(lob1, f3_log), label='Fit invertente 1', color='teal')
plt.plot(f3_log, funzione_fit(lob3, f3_log), label='Fit invertente 3', color='#069AF3')
plt.plot(f3_log, funzione_fit (lob4, f3_log), label='Fit invertente 4', color='red')
plt.plot(f3_log, funzione_fit(lob5, f3_log), label='Fit invertente 5', color='orchid')
plt.xlabel('Frequenza [log_Hz]')
plt.ylabel('Guadagno [dB]')
plt.legend(fontsize='8')
plt.grid()
plt.show()

"""####Estrazione GBP al cutoff"""

#fit
f_cut_tot=np.array([f_cut5, f1_cut, f_cut4, f_cut3])
err_f_cut_tot=np.array([err_f_cut5, err_f1_cut, err_f_cut4, err_f_cut3])
conf=np.array([5, 1, 4, 3])

f_cut_tot_inverso=1/(f_cut_tot)
err_f_cut_tot_inverso=(1/(f_cut_tot**2))*err_f_cut_tot
print(f_cut_tot_inverso, ' +- ', err_f_cut_tot_inverso)

g_reale_tot=np.array([g_reale5[0], g_reale1[0], g_reale4[0], g_reale3[0]])
err_g_reale_tot=np.array([err_g_reale5[0], err_g_reale1[0], err_g_reale4[0], err_g_reale3[0]])
g_cut=g_reale_tot-(1/np.sqrt(2))
err_g_cut=err_g_reale_tot

linear_model = odr.Model(funzione_fit)
data = odr.RealData(f_cut_tot_inverso, g_cut, sx=err_f_cut_tot_inverso, sy=err_g_cut)
linear_odr = odr.ODR(data, linear_model, beta0=[1., 1.])
linear_out = linear_odr.run()
lob6=linear_out.beta
lobs6=linear_out.sd_beta

print("Intercetta A: ", lob6[0], "+-", lobs6[0])
print("Coefficiente angolare B: ", lob6[1], "+-", lobs6[1])
#print(lob6[1]*2*np.pi) -> ho accorpato il 2pi a f_cut_tot_inverso

tab_a=pd.DataFrame(columns=['Configurazione', 'f cutoff [Hz]', '1/f cutoff [s]', 'Guadagno cutoff'])
tab_a['Configurazione']=conf
tab_a['f cutoff [Hz]']=f_cut_tot
tab_a['1/f cutoff [s]']=f_cut_tot_inverso
tab_a['Guadagno cutoff']= g_cut

cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": ".index_name", "props": "font-style: italic; color: #FFFE0; font-weight:normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: black; color: white; text-align: center"}
tab_a.style.format().set_table_styles([cell_hover, index_names, headers]).set_caption('Confronto parametri a diverse configurazioni: cutoff')

plt.figure(figsize=(10,6))
plt.title('Fit lineare di estrazione GBP: cutoff')
plt.errorbar(f_cut_tot_inverso, g_cut, xerr=err_f_cut_tot_inverso, yerr=err_g_cut, fmt='.', color='black', label='Dati sperimentali')
plt.plot(f_cut_tot_inverso, funzione_fit(lob6, f_cut_tot_inverso), label='Fit', color='grey')
plt.xlabel('1/f cutoff [s]')
plt.ylabel('Guadagno [dB]')
plt.legend()
plt.grid()
plt.show()

#Indice di correlazione lineare
f_cut_inverso_m = np.mean(f_cut_tot_inverso)
g_reale_tot_m= np.mean(g_reale_tot)
r=np.sum((f_cut_tot_inverso - f_cut_inverso_m)*(g_reale_tot_m - g_reale_tot))/np.sqrt(np.sum((f_cut_tot_inverso - f_cut_inverso_m)**2)*np.sum((g_reale_tot_m - g_reale_tot)**2))
print('Indice di correlazione lineare:', r)

#Estrazione finale GBP
GBP_tot=lob6[1]*2*np.pi
err_GBP_tot=lobs6[1]*2*np.pi

print('GBP: ', GBP_tot, " +- ", err_GBP_tot)

"""####Estrazione GBP arbitrario"""

#fit
l5=len(f5)-1
l1=len(f1)-1
l4=len(f4)-1
l3=len(f3)-1
f_cut_tot=np.array([f3[len(f3)-1], f4[len(f4)-1], f5[len(f5)-1], f1[len(f1)-1]])
err_f_cut_tot=np.array([err_f3[l3], err_f4[l4], err_f5[l5], errf1[l1]])
conf=np.array([3, 4, 5, 1])

f_cut_tot_inverso=1/(f_cut_tot)
err_f_cut_tot_inverso=(1/(f_cut_tot**2))*err_f_cut_tot
print(f_cut_tot_inverso, ' +- ', err_f_cut_tot_inverso)

g_reale_tot=np.array([g_reale3[l3], g_reale4[l4], g_reale5[l5], g_reale1[l1]])
err_g_reale_tot=np.array([err_g_reale3[l3], err_g_reale4[l4], err_g_reale5[l5], err_g_reale1[l1]])
g_cut=g_reale_tot
err_g_cut=err_g_reale_tot

linear_model = odr.Model(funzione_fit)
data = odr.RealData(f_cut_tot_inverso, g_cut, sx=err_f_cut_tot_inverso, sy=err_g_cut)
linear_odr = odr.ODR(data, linear_model, beta0=[1., 1.])
linear_out = linear_odr.run()
lob7=linear_out.beta
lobs7=linear_out.sd_beta

print("Intercetta A: ", lob7[0], "+-", lobs7[0])
print("Coefficiente angolare B: ", lob7[1], "+-", lobs7[1])

tab_a=pd.DataFrame(columns=['Configurazione', 'f cutoff [Hz]', '1/f cutoff [s]', 'Guadagno cutoff'])
tab_a['Configurazione']=conf
tab_a['f cutoff [Hz]']=f_cut_tot.round(0)
tab_a['1/f cutoff [s]']=f_cut_tot_inverso
tab_a['Guadagno cutoff']= g_cut.round(2)

cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": ".index_name", "props": "font-style: italic; color: #FFFE0; font-weight:normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: black; color: white; text-align: center"}
tab_a.style.format(precision=6).set_table_styles([cell_hover, index_names, headers]).set_caption('Dati estratti per GBP: arbitrari')

plt.figure(figsize=(10,6))
plt.title('Fit lineare di estrazione GBP: arbitrario')
plt.errorbar(f_cut_tot_inverso, g_cut, xerr=err_f_cut_tot_inverso, yerr=err_g_cut, fmt='.', color='black', label='Dati sperimentali')
plt.plot(f_cut_tot_inverso, funzione_fit(lob7, f_cut_tot_inverso), label='Fit', color='grey')
plt.xlabel('1/f cutoff [s]')
plt.ylabel('Guadagno [dB]')
plt.legend()
plt.grid()
plt.show()

#Indice di correlazione lineare
f_cut_inverso_m = np.mean(f_cut_tot_inverso)
g_reale_tot_m= np.mean(g_reale_tot)
r=np.sum((f_cut_tot_inverso - f_cut_inverso_m)*(g_reale_tot_m - g_reale_tot))/np.sqrt(np.sum((f_cut_tot_inverso - f_cut_inverso_m)**2)*np.sum((g_reale_tot_m - g_reale_tot)**2))
print('Indice di correlazione lineare:', r)

#Estrazione finale GBP
GBP_tot_arb=lob7[1]*2*np.pi
err_GBP_tot_arb=lobs7[1]*2*np.pi

print('GBP: ', GBP_tot_arb, " +- ", err_GBP_tot_arb)

"""####GBP estratti"""

# GBP finali di estrazione con iperbole
tab_a=pd.DataFrame(columns=['Metodo', 'GBP [Hz]', 'ε GBP [Hz]'])
tab_a['Metodo']=np.array(['cutoff', 'arbitrario', 'Invertente I', 'Invertente III', 'Invertente IV', 'Invertente V'])
tutti=np.array([GBP_tot, GBP_tot_arb, GBP1, GBP3, GBP4, GBP5])
err_tutti=np.array([err_GBP_tot, err_GBP_tot_arb, err_GBP1, err_GBP3, err_GBP4, err_GBP5])
tab_a['GBP [Hz]']=tutti
tab_a['ε GBP [Hz]']=err_tutti

cell_hover = {"selector": "td:hover", "props": [("background-color", "#FFFE0")]}
index_names = {"selector": ".index_name", "props": "font-style: italic; color: #FFFE0; font-weight:normal;"}
headers = {"selector": "th:not(.index_name)", "props": "background-color: black; color: white; text-align: center"}
tab_a.style.format(precision=0).set_table_styles([cell_hover, index_names, headers]).set_caption('GBP estratti')

"""###Schiacciamento della retta di integratore"""

#Fit retta ideale attesa senza schiacciamento (errore??????)
qualcosa_giu=qualcosa[90:150]
patatina_giu=patatina[90:150]

linear_model = odr.Model(funzione_fit)
data = odr.RealData(np.log10(qualcosa_giu), patatina_giu)
linear_odr = odr.ODR(data, linear_model, beta0=[1., 1.])
linear_out = linear_odr.run()
lob_ideale=linear_out.beta
lobs_ideale=linear_out.sd_beta

print("Intercetta A: ", lob_ideale[0], "+-", lobs_ideale[0])
print("Coefficiente angolare B: ", lob_ideale[1], "+-", lobs_ideale[1])

#Plot completo delle rette di fit
plt.figure(figsize=(10,6))
plt.title('Confronto dei fit lineari a guadagno differente: totali')
plt.plot(f3_log, funzione_fit(lob1, f3_log), label='Fit Invertente 1', color='teal')
plt.plot(f3_log, funzione_fit(lob3, f3_log), label='Fit Invertente 3', color='#069AF3')
plt.plot(f3_log, funzione_fit (lob4, f3_log), label='Fit Invertente 4', color='red')
plt.plot(f3_log, funzione_fit(lob5, f3_log), label='Fit Invertente 5', color='orchid')
plt.plot(f3_log, funzione_fit(lob_int, f3_log), label='Fit Integratore I', color='darkviolet')
plt.plot(f3_log, funzione_fit(lob_int0, f3_log), label='Fit Integratore II', color='mediumspringgreen')
plt.plot(f3_log, funzione_fit(lob_ideale, f3_log), '--', label='Fit Integratore II ideale', color='forestgreen')
plt.xlabel('Frequenza [log_Hz]')
plt.ylabel('Guadagno [dB]')
plt.legend(fontsize='8')
plt.grid()
plt.show()